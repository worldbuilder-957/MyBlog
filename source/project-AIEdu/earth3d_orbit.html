---
layout: false
---
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ°çƒå…¬è½¬è½¨é“ - æ¤­åœ†è½¨é“ä¸å››è‡³ç‚¹å®éªŒ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* æ•™å­¦å¼•å¯¼UIæ ·å¼ */
        #hud-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 20px 25px;
            border-radius: 12px;
            font-size: 16px;
            line-height: 2;
            z-index: 100;
            min-width: 320px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        #hud-panel h2 {
            color: #4CAF50;
            margin-bottom: 15px;
            font-size: 20px;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }

        #hud-panel .info-item {
            margin: 10px 0;
            font-size: 16px;
        }

        #hud-panel .info-label {
            color: #81C784;
            font-weight: bold;
        }

        #hud-panel .info-value {
            color: #fff;
            font-size: 18px;
        }

        /* dat.GUI æ ·å¼è¦†ç›– */
        .dg {
            z-index: 200 !important;
        }

        .dg .c {
            color: #fff !important;
        }

        .dg .property-name {
            color: #fff !important;
        }
    </style>
</head>
<body>
    <!-- 3Dç”»å¸ƒå®¹å™¨ -->
    <div id="canvas-container"></div>

    <!-- æ•™å­¦å¼•å¯¼HUDé¢æ¿ -->
    <div id="hud-panel">
        <h2>ğŸŒ åœ°çƒå…¬è½¬è½¨é“å®éªŒ</h2>
        <div class="info-item">
            <span class="info-label">å½“å‰ä½ç½®ï¼š</span>
            <span class="info-value" id="current-position">æ˜¥åˆ†</span>
        </div>
        <div class="info-item">
            <span class="info-label">å…¬è½¬è§’åº¦ï¼š</span>
            <span class="info-value" id="orbit-angle">0Â°</span>
        </div>
        <div class="info-item">
            <span class="info-label">è½¨é“ç±»å‹ï¼š</span>
            <span class="info-value" id="orbit-type">æ¤­åœ†è½¨é“</span>
        </div>
        <div class="info-item">
            <span class="info-label">å…¬è½¬é€Ÿåº¦ï¼š</span>
            <span class="info-value" id="orbit-speed">æ­£å¸¸</span>
        </div>
    </div>

    <!-- å¼•å…¥ Three.js (r128ç‰ˆæœ¬) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ dat.GUI -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>

    <script>
        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer;
        let sunMesh, earthGroup, earthMesh; // å¤ªé˜³ã€åœ°çƒå®¹å™¨ç»„å’Œåœ°çƒçƒä½“
        let orbitLine; // æ¤­åœ†è½¨é“çº¿
        let solsticePoints = []; // å››è‡³ç‚¹æ ‡è®°
        let orbitGroup; // è½¨é“ç»„
        let sunDirectionalLight; // å¤ªé˜³æ–¹å‘å…‰ï¼ˆç”¨äºç…§äº®åœ°çƒï¼‰
        let stars; // æ˜Ÿæ˜Ÿç²’å­ç³»ç»Ÿ
        let controls; // dat.GUI æ§åˆ¶å¯¹è±¡

        // æ§åˆ¶å‚æ•°
        const params = {
            å…¬è½¬é€Ÿåº¦: 0.5, // å…¬è½¬é€Ÿåº¦å€æ•°
            æ˜¾ç¤ºè½¨é“: true, // æ˜¯å¦æ˜¾ç¤ºæ¤­åœ†è½¨é“
            æ˜¾ç¤ºå››è‡³ç‚¹: true, // æ˜¯å¦æ˜¾ç¤ºå››è‡³ç‚¹æ ‡è®°
            æ˜¾ç¤ºé•¿çŸ­è½´: true, // æ˜¯å¦æ˜¾ç¤ºé•¿çŸ­è½´
            åœ°è½´å€¾æ–œè§’: 23.5, // åœ°è½´å€¾æ–œè§’åº¦
            æ˜¾ç¤ºè‡ªè½¬: true // æ˜¯å¦æ˜¾ç¤ºåœ°çƒè‡ªè½¬
        };

        // æ¤­åœ†è½¨é“å‚æ•°
        const orbitParams = {
            semiMajorAxis: 7.5, // é•¿åŠè½´ï¼ˆè°ƒæ•´ä¸ºåˆé€‚æ¯”ä¾‹ï¼‰
            semiMinorAxis: 7.2, // çŸ­åŠè½´ï¼ˆç¨å¾®å°ä¸€ç‚¹ï¼Œå½¢æˆæ¤­åœ†ï¼‰
            eccentricity: 0.0167 // åå¿ƒç‡ï¼ˆæ¥è¿‘çœŸå®åœ°çƒè½¨é“ï¼‰
        };

        // è‡ªè½¬é€Ÿåº¦
        let rotationSpeed = 0.005;
        // å½“å‰å…¬è½¬è§’åº¦
        let currentOrbitAngle = 0;

        

        // ==================== åˆå§‹åŒ–åœºæ™¯ ====================
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            // å…ˆè®¾ç½®é»˜è®¤é»‘è‰²èƒŒæ™¯
            scene.background = new THREE.Color(0x000000);
            
            // åŠ è½½æ˜Ÿç©ºèƒŒæ™¯å›¾ç‰‡
            const textureLoader = new THREE.TextureLoader();
            let backgroundLoaded = false;
            
            textureLoader.load(
                'star.png',
                function(texture) {
                    // çº¹ç†åŠ è½½æˆåŠŸï¼Œè®¾ç½®ä¸ºåœºæ™¯èƒŒæ™¯
                    backgroundLoaded = true;
                    scene.background = texture;
                    console.log('æ˜Ÿç©ºèƒŒæ™¯å›¾ç‰‡åŠ è½½æˆåŠŸ');
                },
                undefined,
                function(err) {
                    // çº¹ç†åŠ è½½å¤±è´¥ï¼Œç«‹å³åˆ›å»ºç²’å­æ˜Ÿæ˜Ÿ
                    console.error('æ˜Ÿç©ºèƒŒæ™¯å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œé”™è¯¯:', err);
                    backgroundLoaded = false;
                    scene.background = new THREE.Color(0x000000);
                    createStars();
                }
            );
            
            // å»¶è¿Ÿæ£€æŸ¥ï¼šå¦‚æœ2ç§’åèƒŒæ™¯ä»ç„¶æ˜¯çº¯é»‘è‰²ï¼Œè¯´æ˜å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œåˆ›å»ºç²’å­æ˜Ÿæ˜Ÿ
            // è¿™æ˜¯ä¸€ä¸ªå¤‡ç”¨æœºåˆ¶ï¼Œé˜²æ­¢é”™è¯¯å›è°ƒæ²¡æœ‰è§¦å‘
            setTimeout(function() {
                if (!backgroundLoaded) {
                    // æ£€æŸ¥èƒŒæ™¯æ˜¯å¦ä»ç„¶æ˜¯çº¯é»‘è‰²
                    const isBlack = scene.background && 
                                   ((scene.background.isColor && scene.background.getHex() === 0x000000) ||
                                    (scene.background && !scene.background.isTexture));
                    if (isBlack) {
                        console.log('èƒŒæ™¯å›¾ç‰‡åŠ è½½è¶…æ—¶ï¼Œåˆ›å»ºç²’å­æ˜Ÿæ˜Ÿç³»ç»Ÿ');
                        scene.background = new THREE.Color(0x000000);
                        createStars();
                    }
                }
            }, 2000);

            // åˆ›å»ºç›¸æœºï¼ˆé€è§†ç›¸æœºï¼‰
            camera = new THREE.PerspectiveCamera(
                75, // è§†é‡è§’åº¦
                window.innerWidth / window.innerHeight, // å®½é«˜æ¯”
                0.1, // è¿‘è£å‰ªé¢
                1000 // è¿œè£å‰ªé¢
            );
            camera.position.set(0, 12, 18); // è®¾ç½®ç›¸æœºä½ç½®ï¼Œä»ä¸Šæ–¹è§‚å¯Ÿï¼ˆè°ƒæ•´ä»¥é€‚åº”æ›´å¤§çš„æ¨¡å‹ï¼‰
            camera.lookAt(0, 0, 0);

            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);


            // ==================== åˆ›å»ºå…‰æº ====================
            // ç¯å¢ƒå…‰ï¼ˆé™ä½å¼ºåº¦ï¼Œè®©å…‰ç…§å¯¹æ¯”æ›´æ˜æ˜¾ï¼‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.15);
            scene.add(ambientLight);

            // ç‚¹å…‰æºï¼ˆå¤ªé˜³å…‰ï¼Œç”¨äºæ•´ä½“ç…§æ˜ï¼‰
            const sunLight = new THREE.PointLight(0xffffff, 1.5, 100);
            scene.add(sunLight);

            // æ–¹å‘å…‰ï¼ˆä»å¤ªé˜³æŒ‡å‘åœ°çƒï¼Œè®©åœ°çƒé¢å‘å¤ªé˜³çš„ä¸€ä¾§æ›´äº®ï¼‰
            sunDirectionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunDirectionalLight.position.set(0, 0, 0); // ä»å¤ªé˜³ä½ç½®å¼€å§‹
            sunDirectionalLight.target.position.set(0, 0, 0); // åˆå§‹ç›®æ ‡ä½ç½®
            scene.add(sunDirectionalLight);
            scene.add(sunDirectionalLight.target); // å¿…é¡»å°†targetæ·»åŠ åˆ°åœºæ™¯ä¸­

            // ==================== åˆ›å»ºå¤ªé˜³ ====================
            const sunGeometry = new THREE.SphereGeometry(1.0, 32, 32); // å¤ªé˜³åŠå¾„å¢å¤§ä¸€å€ï¼ˆ0.5 -> 1.0ï¼‰
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa00,
                emissive: 0xffaa00
            });
            sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.set(0, 0, 0); // å¤ªé˜³åœ¨ä¸­å¿ƒ
            scene.add(sunMesh);

            // å¤ªé˜³å…‰è·Ÿéšå¤ªé˜³ä½ç½®
            sunLight.position.copy(sunMesh.position);

            // ==================== åˆ›å»ºæ¤­åœ†è½¨é“ ====================
            orbitGroup = new THREE.Group();
            createOrbitLine();
            createSolsticePoints();
            createAxes();
            scene.add(orbitGroup);

            // ==================== åˆ›å»ºåœ°çƒ ====================
            earthGroup = new THREE.Group();
            
            // åœ°çƒå‡ ä½•ä½“
            const earthGeometry = new THREE.SphereGeometry(0.6, 32, 32); // åœ°çƒåŠå¾„å¢å¤§ä¸€å€ï¼ˆ0.3 -> 0.6ï¼‰
            
            // åœ°çƒæè´¨ï¼ˆç®€å•çš„åœ°çƒçº¹ç†ï¼‰
            const textureLoader = new THREE.TextureLoader();
            const earthTexture = textureLoader.load(
                'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg',
                undefined,
                undefined,
                function(err) {
                    console.log('åœ°çƒçº¹ç†åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨ç¨‹åºåŒ–æè´¨');
                }
            );
            
            const earthMaterial = new THREE.MeshStandardMaterial({
                map: earthTexture,
                roughness: 0.8,
                metalness: 0.2
            });
            
            earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
            earthGroup.add(earthMesh);

            // è®¾ç½®åœ°è½´å€¾æ–œ
            earthGroup.rotation.z = THREE.MathUtils.degToRad(params.åœ°è½´å€¾æ–œè§’);

            // åˆå§‹ä½ç½®ï¼šæ˜¥åˆ†ç‚¹ï¼ˆé•¿è½´å³ç«¯ç‚¹ï¼‰
            updateEarthPosition(0);
            scene.add(earthGroup);

            // ==================== åˆ›å»ºæ§åˆ¶é¢æ¿ (dat.GUI) ====================
            const gui = new dat.GUI({ autoPlace: true });
            gui.domElement.style.position = 'absolute';
            gui.domElement.style.top = '20px';
            gui.domElement.style.right = '20px';

            // å…¬è½¬é€Ÿåº¦æ§åˆ¶å™¨
            gui.add(params, 'å…¬è½¬é€Ÿåº¦', 0, 3, 0.1)
                .name('å…¬è½¬é€Ÿåº¦')
                .onChange(function(value) {
                    updateHUD();
                });

            // æ˜¾ç¤ºè½¨é“å¼€å…³
            gui.add(params, 'æ˜¾ç¤ºè½¨é“')
                .name('æ˜¾ç¤ºè½¨é“')
                .onChange(function(value) {
                    if (orbitLine) {
                        orbitLine.visible = value;
                    }
                });

            // æ˜¾ç¤ºå››è‡³ç‚¹å¼€å…³
            gui.add(params, 'æ˜¾ç¤ºå››è‡³ç‚¹')
                .name('æ˜¾ç¤ºå››è‡³ç‚¹')
                .onChange(function(value) {
                    solsticePoints.forEach(point => {
                        if (point) point.visible = value;
                    });
                });

            // æ˜¾ç¤ºé•¿çŸ­è½´å¼€å…³
            gui.add(params, 'æ˜¾ç¤ºé•¿çŸ­è½´')
                .name('æ˜¾ç¤ºé•¿çŸ­è½´')
                .onChange(function(value) {
                    // æ›´æ–°é•¿çŸ­è½´æ˜¾ç¤º
                    updateAxesVisibility(value);
                });

            // åœ°è½´å€¾æ–œè§’æ§åˆ¶å™¨
            gui.add(params, 'åœ°è½´å€¾æ–œè§’', 0, 90, 0.1)
                .name('åœ°è½´å€¾æ–œè§’ (Â°)')
                .onChange(function(value) {
                    earthGroup.rotation.z = THREE.MathUtils.degToRad(value);
                    updateHUD();
                });

            // æ˜¾ç¤ºè‡ªè½¬å¼€å…³
            gui.add(params, 'æ˜¾ç¤ºè‡ªè½¬')
                .name('æ˜¾ç¤ºè‡ªè½¬')
                .onChange(function(value) {
                    updateHUD();
                });

            controls = gui;

            // ==================== çª—å£å¤§å°è°ƒæ•´å¤„ç† ====================
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // åˆå§‹åŒ–HUD
            updateHUD();

            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
        }

        // ==================== åˆ›å»ºæ¤­åœ†è½¨é“çº¿ ====================
        function createOrbitLine() {
            const points = [];
            const segments = 128;
            
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = orbitParams.semiMajorAxis * Math.cos(angle);
                const z = orbitParams.semiMinorAxis * Math.sin(angle);
                points.push(new THREE.Vector3(x, 0, z));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x00ffff, // é’è‰²
                transparent: true,
                opacity: 0.6
            });
            
            orbitLine = new THREE.Line(geometry, material);
            orbitGroup.add(orbitLine);
        }

        // ==================== åˆ›å»ºå››è‡³ç‚¹æ ‡è®° ====================
        function createSolsticePoints() {
            const solsticeAngles = [
                { angle: 0, name: 'æ˜¥åˆ†', color: 0x00ff00 },      // 0åº¦ - æ˜¥åˆ†ï¼ˆé•¿è½´å³ç«¯ç‚¹ï¼‰
                { angle: 90, name: 'å¤è‡³', color: 0xff0000 },    // 90åº¦ - å¤è‡³
                { angle: 180, name: 'ç§‹åˆ†', color: 0xffff00 },    // 180åº¦ - ç§‹åˆ†ï¼ˆé•¿è½´å·¦ç«¯ç‚¹ï¼‰
                { angle: 270, name: 'å†¬è‡³', color: 0x0000ff }    // 270åº¦ - å†¬è‡³
            ];

            solsticeAngles.forEach(({ angle, name, color }) => {
                const radAngle = THREE.MathUtils.degToRad(angle);
                const x = orbitParams.semiMajorAxis * Math.cos(radAngle);
                const z = orbitParams.semiMinorAxis * Math.sin(radAngle);

                // åˆ›å»ºæ ‡è®°çƒä½“
                const markerGeometry = new THREE.SphereGeometry(0.2, 16, 16); // ç¨å¾®å¢å¤§æ ‡è®°ä»¥é€‚åº”æ›´å¤§çš„è½¨é“
                const markerMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(x, 0, z);
                marker.userData.name = name;
                marker.userData.angle = angle;
                
                orbitGroup.add(marker);
                solsticePoints.push(marker);

                // æ·»åŠ æ–‡å­—æ ‡ç­¾ï¼ˆä½¿ç”¨ç®€å•çš„å‡ ä½•ä½“è¡¨ç¤ºï¼‰
                const labelGeometry = new THREE.RingGeometry(0.25, 0.3, 16); // å¢å¤§æ ‡ç­¾ç¯ä»¥é€‚åº”æ›´å¤§çš„è½¨é“
                const labelMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const label = new THREE.Mesh(labelGeometry, labelMaterial);
                label.position.set(x, 0.01, z);
                label.rotation.x = -Math.PI / 2;
                orbitGroup.add(label);
            });
        }

        // ==================== åˆ›å»ºé•¿çŸ­è½´ ====================
        let majorAxisLine, minorAxisLine;
        
        function createAxes() {
            // é•¿è½´ï¼ˆXè½´æ–¹å‘ï¼‰
            const majorAxisGeometry = new THREE.BufferGeometry();
            const majorAxisPoints = [
                -orbitParams.semiMajorAxis, 0, 0,
                orbitParams.semiMajorAxis, 0, 0
            ];
            majorAxisGeometry.setAttribute('position', new THREE.Float32BufferAttribute(majorAxisPoints, 3));
            const majorAxisMaterial = new THREE.LineDashedMaterial({
                color: 0xff00ff, // å“çº¢è‰²
                dashSize: 0.2,
                gapSize: 0.1,
                transparent: true,
                opacity: 0.5
            });
            majorAxisLine = new THREE.Line(majorAxisGeometry, majorAxisMaterial);
            majorAxisLine.computeLineDistances();
            orbitGroup.add(majorAxisLine);

            // çŸ­è½´ï¼ˆZè½´æ–¹å‘ï¼‰
            const minorAxisGeometry = new THREE.BufferGeometry();
            const minorAxisPoints = [
                0, 0, -orbitParams.semiMinorAxis,
                0, 0, orbitParams.semiMinorAxis
            ];
            minorAxisGeometry.setAttribute('position', new THREE.Float32BufferAttribute(minorAxisPoints, 3));
            const minorAxisMaterial = new THREE.LineDashedMaterial({
                color: 0x00ffff, // é’è‰²
                dashSize: 0.2,
                gapSize: 0.1,
                transparent: true,
                opacity: 0.5
            });
            minorAxisLine = new THREE.Line(minorAxisGeometry, minorAxisMaterial);
            minorAxisLine.computeLineDistances();
            orbitGroup.add(minorAxisLine);
        }

        // ==================== æ›´æ–°é•¿çŸ­è½´æ˜¾ç¤º ====================
        function updateAxesVisibility(visible) {
            if (majorAxisLine) majorAxisLine.visible = visible;
            if (minorAxisLine) minorAxisLine.visible = visible;
        }

        // ==================== æ›´æ–°åœ°çƒä½ç½® ====================
        function updateEarthPosition(angle) {
            const radAngle = THREE.MathUtils.degToRad(angle);
            const x = orbitParams.semiMajorAxis * Math.cos(radAngle);
            const z = orbitParams.semiMinorAxis * Math.sin(radAngle);
            
            earthGroup.position.set(x, 0, z);
            
            // æ›´æ–°æ–¹å‘å…‰ï¼Œä½¿å…¶ä»å¤ªé˜³æŒ‡å‘åœ°çƒï¼Œç…§äº®åœ°çƒé¢å‘å¤ªé˜³çš„ä¸€ä¾§
            if (sunDirectionalLight && earthGroup) {
                // è®¡ç®—ä»å¤ªé˜³åˆ°åœ°çƒçš„æ–¹å‘å‘é‡
                const sunPosition = new THREE.Vector3(0, 0, 0);
                const earthPosition = earthGroup.position.clone();
                
                // æ–¹å‘å…‰çš„ä½ç½®è®¾ç½®åœ¨å¤ªé˜³å’Œåœ°çƒä¹‹é—´ï¼Œæ›´é è¿‘å¤ªé˜³
                const lightPosition = sunPosition.clone().lerp(earthPosition, 0.3);
                sunDirectionalLight.position.copy(lightPosition);
                
                // æ–¹å‘å…‰çš„targetæŒ‡å‘åœ°çƒä¸­å¿ƒ
                sunDirectionalLight.target.position.copy(earthPosition);
            }
        }

        // ==================== è·å–å½“å‰ä½ç½®åç§° ====================
        function getPositionName(angle) {
            // å°†è§’åº¦å½’ä¸€åŒ–åˆ°0-360
            const normalizedAngle = ((angle % 360) + 360) % 360;
            
            if (normalizedAngle >= 0 && normalizedAngle < 45) return 'æ˜¥åˆ†';
            if (normalizedAngle >= 45 && normalizedAngle < 135) return 'å¤è‡³';
            if (normalizedAngle >= 135 && normalizedAngle < 225) return 'ç§‹åˆ†';
            if (normalizedAngle >= 225 && normalizedAngle < 315) return 'å†¬è‡³';
            return 'æ˜¥åˆ†';
        }

        // ==================== æ›´æ–°HUDé¢æ¿ ====================
        function updateHUD() {
            const normalizedAngle = ((currentOrbitAngle % 360) + 360) % 360;
            document.getElementById('current-position').textContent = getPositionName(normalizedAngle);
            document.getElementById('orbit-angle').textContent = normalizedAngle.toFixed(1) + 'Â°';
            document.getElementById('orbit-type').textContent = 'æ¤­åœ†è½¨é“';
            
            let speedText = 'æ­£å¸¸';
            if (params.å…¬è½¬é€Ÿåº¦ < 0.5) speedText = 'æ…¢é€Ÿ';
            else if (params.å…¬è½¬é€Ÿåº¦ > 1.5) speedText = 'å¿«é€Ÿ';
            document.getElementById('orbit-speed').textContent = speedText;
        }

        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);

            // åœ°çƒå…¬è½¬
            currentOrbitAngle += params.å…¬è½¬é€Ÿåº¦ * 0.5;
            if (currentOrbitAngle >= 360) {
                currentOrbitAngle -= 360;
            }
            updateEarthPosition(currentOrbitAngle);

            // åœ°çƒè‡ªè½¬
            if (earthMesh && params.æ˜¾ç¤ºè‡ªè½¬) {
                earthMesh.rotation.y += rotationSpeed;
            }

            // æ›´æ–°HUD
            updateHUD();

            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }

        // ==================== å¯åŠ¨åº”ç”¨ ====================
        init();
    </script>
</body>
</html>

